// Copyright 2022-2023 Protocol Labs
// Copyright 2019-2022 ChainSafe Systems
// SPDX-License-Identifier: MIT
use std::{
    borrow::Cow,
    cmp,
    collections::VecDeque,
    task::{Context, Poll},
    time::Duration,
};

use libp2p::{
    core::{connection::ConnectionId, identity::PublicKey},
    kad::{
        handler::KademliaHandlerProto, store::MemoryStore, Kademlia, KademliaConfig, KademliaEvent,
        QueryId,
    },
    multiaddr::Protocol,
    swarm::{
        behaviour::toggle::{Toggle, ToggleIntoConnectionHandler},
        derive_prelude::FromSwarm,
        ConnectionHandler, IntoConnectionHandler, NetworkBehaviour, NetworkBehaviourAction,
        PollParameters,
    },
    Multiaddr, PeerId,
};
use log::debug;
use thiserror::Error;
use tokio::time::Interval;

// NOTE: The Discovery behaviour is largely based on what exists in Forest. If it ain't broken...
// NOTE: Not sure if emitting events is going to be useful yet, but for now it's an example of having one.

/// Event generated by the `Discovery` behaviour.
#[derive(Debug)]
pub enum Event {
    /// Event emitted when we first connect to a peer.
    Connected(PeerId, Vec<Multiaddr>),

    /// Event emitted when the last connection to a peer is closed.
    Disconnected(PeerId, Vec<Multiaddr>),
}

/// `Discovery` behaviour configuration.
#[derive(Clone, Debug)]
pub struct Config {
    /// Our own peer ID, needed to bootstrap Kademlia.
    local_peer_id: PeerId,
    /// Static list of addresses to bootstrap from.
    user_defined: Vec<(PeerId, Multiaddr)>,
    /// Number of connections at which point we pause further discovery lookups.
    target_connections: usize,
    /// Option to disable Kademlia, for example in a fixed static network.
    enable_kademlia: bool,
    /// Name of the network in the Kademlia protocol.
    network_name: String,
}

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("invalid network: {0}")]
    InvalidNetwork(String),
    #[error("invalid bootstrap address: {0}")]
    InvalidBootstrapAddress(Multiaddr),
    #[error("no bootstrap address")]
    NoBootstrapAddress,
}

pub struct ConfigBuilder(Config);

impl ConfigBuilder {
    /// Create a default configuration with the given public key.
    pub fn new(local_public_key: PublicKey, network_name: String) -> Result<Self, ConfigError> {
        if network_name.is_empty() {
            Err(ConfigError::InvalidNetwork(network_name))
        } else {
            Ok(Self(Config {
                local_peer_id: local_public_key.to_peer_id(),
                user_defined: Vec::new(),
                target_connections: usize::MAX,
                enable_kademlia: true,
                network_name,
            }))
        }
    }

    /// Set the number of active connections at which we pause discovery.
    pub fn with_max_connections(&mut self, limit: usize) -> &mut Self {
        self.0.target_connections = limit;
        self
    }

    /// Set custom nodes which never expire, e.g. bootstrap or reserved nodes.
    ///
    /// The addresses must end with a `/p2p/<peer-id>` part.
    pub fn with_user_defined<I>(&mut self, user_defined: I) -> Result<&mut Self, ConfigError>
    where
        I: IntoIterator<Item = Multiaddr>,
    {
        for multiaddr in user_defined {
            let mut addr = multiaddr.clone();
            if let Some(Protocol::P2p(mh)) = addr.pop() {
                let peer_id = PeerId::from_multihash(mh).unwrap();
                self.0.user_defined.push((peer_id, addr))
            } else {
                return Err(ConfigError::InvalidBootstrapAddress(multiaddr));
            }
        }
        Ok(self)
    }

    /// Configures if Kademlia is enabled.
    pub fn with_kademlia(&mut self, value: bool) -> &mut Self {
        self.0.enable_kademlia = value;
        self
    }

    /// Finish configuration and do a final check.
    pub fn build(self) -> Result<Config, ConfigError> {
        if self.0.enable_kademlia && self.0.user_defined.is_empty() {
            Err(ConfigError::NoBootstrapAddress)
        } else {
            Ok(self.0)
        }
    }
}

/// Discovery behaviour, periodically running a random lookup with Kademlia to find new peers.
///
/// Our other option for peer discovery would be to rely on the Peer Exchange of Gossipsub.
/// However, the required Signed Records feature is not available in the Rust version of the library, as of v0.50.
pub struct Behaviour {
    /// User-defined list of nodes and their addresses.
    /// Typically includes bootstrap nodes, or it can be used for a static network.
    user_defined: Vec<(PeerId, Multiaddr)>,
    /// Kademlia behaviour, if enabled.
    inner: Toggle<Kademlia<MemoryStore>>,
    /// Number of current connections.
    num_connections: usize,
    /// Number of connections where further lookups are paused.
    target_connections: usize,
    /// Interval between random lookups.
    lookup_interval: Interval,
    /// Events to return when polled.
    outbox: VecDeque<Event>,
}

impl Behaviour {
    /// Create a [`discovery::Behaviour`] from this configuration.
    pub fn new(config: Config) -> Self {
        let kademlia_opt = if config.enable_kademlia {
            let mut kad_config = KademliaConfig::default();
            let protocol_name = format!("/ipc/kad/{}/kad/1.0.0", config.network_name);
            kad_config.set_protocol_names(vec![Cow::Owned(protocol_name.as_bytes().to_vec())]);

            let store = MemoryStore::new(config.local_peer_id);

            let mut kademlia = Kademlia::with_config(config.local_peer_id, store, kad_config);

            for (peer_id, addr) in config.user_defined.iter() {
                kademlia.add_address(peer_id, addr.clone());
            }

            // This shouldn't happen, we already checked the config.
            kademlia
                .bootstrap()
                .unwrap_or_else(|e| panic!("Kademlia bootstrap failed: {}", e));

            Some(kademlia)
        } else {
            None
        };

        Self {
            user_defined: config.user_defined,
            inner: kademlia_opt.into(),
            lookup_interval: tokio::time::interval(Duration::from_secs(1)),
            outbox: VecDeque::new(),
            num_connections: 0,
            target_connections: config.target_connections,
        }
    }

    /// Lookup a peer, unless we already know their address, so that we have a chance to connect to them later.
    pub fn background_lookup(&mut self, peer_id: PeerId) {
        if self.addresses_of_peer(&peer_id).is_empty() {
            if let Some(kademlia) = self.inner.as_mut() {
                kademlia.get_closest_peers(peer_id);
            }
        }
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = ToggleIntoConnectionHandler<KademliaHandlerProto<QueryId>>;

    type OutEvent = Event;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        self.inner.new_handler()
    }

    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        let mut addrs = self
            .user_defined
            .iter()
            .filter(|(p, _)| p == peer_id)
            .map(|(_, a)| a.clone())
            .collect::<Vec<_>>();

        addrs.extend(self.inner.addresses_of_peer(peer_id));
        addrs
    }

    fn on_swarm_event(&mut self, event: FromSwarm<Self::ConnectionHandler>) {
        match &event {
            FromSwarm::ConnectionEstablished(e) => {
                self.num_connections += 1;
                if e.other_established == 0 {
                    let addrs = self.addresses_of_peer(&e.peer_id);
                    self.outbox.push_back(Event::Connected(e.peer_id, addrs));
                }
            }
            FromSwarm::ConnectionClosed(e) => {
                self.num_connections -= 1;
                if e.remaining_established == 0 {
                    let addrs = self.addresses_of_peer(&e.peer_id);
                    self.outbox.push_back(Event::Disconnected(e.peer_id, addrs));
                }
            }
            _ => {}
        };
        self.inner.on_swarm_event(event)
    }

    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        event: <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as ConnectionHandler>::OutEvent,
    ) {
        self.inner
            .on_connection_handler_event(peer_id, connection_id, event)
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        params: &mut impl PollParameters,
    ) -> std::task::Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        // Emit own events first.
        if let Some(ev) = self.outbox.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
        }

        // Trigger periodic queries.
        if self.lookup_interval.poll_tick(cx).is_ready() {
            if self.num_connections < self.target_connections {
                if let Some(k) = self.inner.as_mut() {
                    let random_peer_id = PeerId::random();
                    k.get_closest_peers(random_peer_id);
                }
            }

            // Schedule the next random query with exponentially increasing delay, capped at 60 seconds.
            self.lookup_interval = tokio::time::interval(cmp::min(
                self.lookup_interval.period() * 2,
                Duration::from_secs(60),
            ));
            // we need to reset the interval, otherwise the next tick completes immediately.
            self.lookup_interval.reset();
        }

        // Poll Kademlia.
        while let Poll::Ready(ev) = self.inner.poll(cx, params) {
            match ev {
                // Not propagating Kademlia specific events, just the ones meant for the Swarm.
                // The Kademlia configuration should ensure that peers are added automatically to the bucket,
                // without need for manual action, so this should be informational only.
                // The only event which could be a warning is the `UnroutablePeer`; I don't fully understand
                // under which conditions it can arise though. It might be a good idea to log that.
                NetworkBehaviourAction::GenerateEvent(out) => {
                    if let ev @ KademliaEvent::UnroutablePeer { .. } = out {
                        debug!("unexpected Kademlia event: {ev:?}")
                    }
                    continue;
                }
                other => {
                    return Poll::Ready(other.map_out(|_| unreachable!("continue'd")));
                }
            }
        }

        Poll::Pending
    }
}
